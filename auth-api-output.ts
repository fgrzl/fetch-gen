// Auto-generated by fetch-gen
import type { FetchClient, FetchResponse } from '@fgrzl/fetch';
import { buildQueryParams } from '@fgrzl/fetch';

/**
 * Creates an API adapter with typed methods for all OpenAPI operations.
 *
 * @param client - The FetchClient instance to use for HTTP requests
 * @returns An object with typed methods for each API operation
 *
 * @example
 * ```typescript
 * import { createAdapter } from './generated';
 * import client from '@fgrzl/fetch';
 *
 * client.setBaseUrl('https://api.example.com');
 * const api = createAdapter(client);
 *
 * const response = await api.getUsers();
 * if (response.ok) {
 *   console.log(response.data);
 * }
 * ```
 */
export function createAdapter(client: FetchClient): {
  /**
   * Detect SSO providers for an email address
   *
   * @param query - Query parameters
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<Array<string>>
   */
  detectSSOProviders: (query?: { email?: string }, options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<Array<string>>>;
  /**
   * Get JSON Web Key Set
   *
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<JWKSResponse>
   */
  getJWKS: (options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<JWKSResponse>>;
  /**
   * Handle SSO callback
   *
   * @param provider - provider parameter
   * @param query - Query parameters
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<boolean>
   */
  ssoCallback: (provider: string, query?: { code?: string; state?: string }, options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<boolean>>;
  /**
   * Initiate SSO login flow
   *
   * @param provider - provider parameter
   * @param query - Query parameters
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<boolean>
   */
  ssoLogin: (provider: string, query?: { email?: string; return_url?: string }, options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<boolean>>;
  /**
   * Logout user
   *
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<boolean>
   */
  logout: (options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<boolean>>;
  /**
   * Get current user information
   *
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<UserIdentity>
   */
  getCurrentUser: (options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<UserIdentity>>;
  /**
   * Get email verification status
   *
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<EmailVerificationStatus>
   */
  getVerificationStatus: (options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<EmailVerificationStatus>>;
  /**
   * Verify email address
   *
   * @param query - Query parameters
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<boolean>
   */
  verifyEmail: (query?: { email?: string; token?: string }, options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<boolean>>;
  /**
   * Resend verification email
   *
	 * @param options - Request options (signal, timeout)
   * @returns Promise resolving to FetchResponse<EmailVerificationStatus>
   */
  resendVerification: (options?: { signal?: AbortSignal; timeout?: number }) => Promise<FetchResponse<EmailVerificationStatus>>;
} {
  return {
    detectSSOProviders: (query?: { email?: string }, options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<Array<string>>> => {
      const queryString = query ? buildQueryParams(query) : '';
      const url = `/api/v1/sso/detect` + (queryString ? '?' + queryString : '');
			return client.get(url, undefined, options);
    },
    getJWKS: (options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<JWKSResponse>> => {
	return client.get(`/auth/.well-known/jwks.json`, undefined, options);
    },
    ssoCallback: (provider: string, query?: { code?: string; state?: string }, options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<boolean>> => {
      const queryString = query ? buildQueryParams(query) : '';
      const url = `/auth/callback/${provider}` + (queryString ? '?' + queryString : '');
			return client.get(url, undefined, options);
    },
    ssoLogin: (provider: string, query?: { email?: string; return_url?: string }, options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<boolean>> => {
      const queryString = query ? buildQueryParams(query) : '';
      const url = `/auth/login/${provider}` + (queryString ? '?' + queryString : '');
			return client.get(url, undefined, options);
    },
    logout: (options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<boolean>> => {
	return client.get(`/auth/logout`, undefined, options);
    },
    getCurrentUser: (options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<UserIdentity>> => {
	return client.get(`/auth/me`, undefined, options);
    },
    getVerificationStatus: (options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<EmailVerificationStatus>> => {
	return client.get(`/auth/verification-status`, undefined, options);
    },
    verifyEmail: (query?: { email?: string; token?: string }, options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<boolean>> => {
      const queryString = query ? buildQueryParams(query) : '';
      const url = `/auth/verify` + (queryString ? '?' + queryString : '');
			return client.get(url, undefined, options);
    },
    resendVerification: (options?: { signal?: AbortSignal; timeout?: number }): Promise<FetchResponse<EmailVerificationStatus>> => {
	return client.post(`/auth/verify/resend`, undefined, undefined, options);
    }
  };
}

/** EmailVerificationStatus schema */
export interface EmailVerificationStatus {
  email?: string;
  expires_at?: string;
  is_verified?: boolean;
  requested_at?: string;
  user_id?: string;
  verification_url?: string;
}

/** JWKResponse schema */
export interface JWKResponse {
  alg?: string;
  e?: string;
  kty?: string;
  n?: string;
  use?: string;
}

/** JWKSResponse schema */
export interface JWKSResponse {
  keys?: Array<JWKResponse>;
}

/** ProblemDetails schema */
export interface ProblemDetails {
  detail?: string;
  instance?: string;
  status?: number;
  title?: string;
  type?: string;
}

/** UserIdentity schema */
export interface UserIdentity {
  email?: string;
  name?: string;
  user_id?: string;
}

